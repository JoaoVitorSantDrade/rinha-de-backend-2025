worker_processes auto;
worker_rlimit_nofile 65535;

events {
    use epoll;
    worker_connections 16000;
    multi_accept on;
}

http {
    lua_shared_dict round_robin_state 1m;
    lua_shared_dict request_stats 1m;

    lua_code_cache on;

    resolver 127.0.0.11 ipv6=off;

    access_log off;
    error_log /usr/local/openresty/nginx/logs/error.log error;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    keepalive_requests 1000;

    client_body_buffer_size 16k;
    client_max_body_size 1m;

    upstream backend {
        server api1:8080 max_fails=2 fail_timeout=30s;
        server api2:8081 max_fails=2 fail_timeout=30s;
        keepalive 400;
        keepalive_requests 1000;
        keepalive_timeout 60s;
    }

    init_by_lua_block {
        local dict = ngx.shared.round_robin_state
        dict:set("counter", 0)

        local stats = ngx.shared.request_stats
        stats:set("total_requests", 0)
        stats:set("async_requests", 0)
        stats:set("failed_requests", 0)
    }

    server {
        listen 9999 reuseport;

        location /health {
            content_by_lua_block {
                local stats = ngx.shared.request_stats
                local total = stats:get("total_requests") or 0
                local async = stats:get("async_requests") or 0
                local failed = stats:get("failed_requests") or 0

                ngx.header["Content-Type"] = "application/json"
                ngx.say(string.format([[{
                    "status": "healthy",
                    "total_requests": %d,
                    "async_requests": %d,
                    "failed_requests": %d,
                    "timestamp": %.2f
                }]], total, async, failed, ngx.now()))
            }
        }

        location / {
            if ($request_method = POST) {
                lua_need_request_body on;

                content_by_lua_block {
                    local stats = ngx.shared.request_stats
                    stats:incr("total_requests", 1)
                    stats:incr("async_requests", 1)

                    local method = ngx.var.request_method
                    local uri = ngx.var.uri
                    local args = ngx.var.args
                    local body = ngx.req.get_body_data()

                    if not body then
                        local body_file = ngx.req.get_body_file()
                        if body_file then
                            local f = io.open(body_file, "r")
                            if f then
                                body = f:read("*all")
                                f:close()
                            end
                        end
                    end

                    local headers = {}
                    local h = ngx.req.get_headers()
                    for k, v in pairs(h) do
                        local lower_k = string.lower(k)
                        if lower_k ~= "connection" and lower_k ~= "keep-alive" and
                           lower_k ~= "transfer-encoding" and lower_k ~= "upgrade" and
                           lower_k ~= "proxy-authenticate" and lower_k ~= "proxy-authorization" and
                           lower_k ~= "te" and lower_k ~= "trailers" and lower_k ~= "content-length" and
                           lower_k ~= "host" then
                            headers[k] = v
                        end
                    end

                    local request_id = ngx.var.request_id or tostring(ngx.now())

                    ngx.status = 201
                    ngx.header["Content-Type"] = "application/json"
                    ngx.header["X-Request-ID"] = request_id
                    ngx.say(string.format([[{
                        "status": "accepted",
                        "message": "Payment queued for processing",
                        "request_id": "%s"
                    }]], request_id))

                    ngx.flush(true)
                    ngx.eof()

                    local function process_in_background(premature)
                        if premature then
                            return
                        end

                        local dict = ngx.shared.round_robin_state
                        local counter = dict:incr("counter", 1) or 1
                        local backend_index = (counter % 2) + 1
                        local backend_host = backend_index == 1 and "api1:8080" or "api2:8081"

                        local full_url = "http://" .. backend_host .. uri
                        if args then
                            full_url = full_url .. "?" .. args
                        end

                        local sock = ngx.socket.tcp()
                        sock:settimeout(5000)

                        local ok, err = sock:connect(backend_host:match("([^:]+)"),
                                                     tonumber(backend_host:match(":(%d+)")) or 80)

                        if not ok then
                            ngx.log(ngx.ERR, "Failed to connect to backend: ", err,
                                    " for request ", request_id)
                            stats:incr("failed_requests", 1)
                            return
                        end

                        local request_line = method .. " " .. uri
                        if args then
                            request_line = request_line .. "?" .. args
                        end
                        request_line = request_line .. " HTTP/1.1\r\n"

                        local header_str = request_line
                        header_str = header_str .. "Host: " .. backend_host .. "\r\n"

                        for k, v in pairs(headers) do
                            header_str = header_str .. k .. ": " .. tostring(v) .. "\r\n"
                        end

                        if body then
                            header_str = header_str .. "Content-Length: " .. #body .. "\r\n"
                        end

                        header_str = header_str .. "X-Request-ID: " .. request_id .. "\r\n"
                        header_str = header_str .. "Connection: keep-alive\r\n\r\n"

                        local bytes, err = sock:send(header_str)
                        if not bytes then
                            ngx.log(ngx.ERR, "Failed to send headers: ", err,
                                    " for request ", request_id)
                            stats:incr("failed_requests", 1)
                            sock:close()
                            return
                        end

                        if body then
                            bytes, err = sock:send(body)
                            if not bytes then
                                ngx.log(ngx.ERR, "Failed to send body: ", err,
                                        " for request ", request_id)
                                stats:incr("failed_requests", 1)
                                sock:close()
                                return
                            end
                        end

                        local reader = sock:receiveuntil("\r\n\r\n")
                        local headers, err = reader()

                        if not headers then
                            ngx.log(ngx.ERR, "Failed to read response: ", err,
                                    " for request ", request_id)
                            stats:incr("failed_requests", 1)
                        else
                            local status = headers:match("HTTP/%d%.%d (%d%d%d)")
                            ngx.log(ngx.INFO, "Processed request ", request_id,
                                    " with status ", status)
                        end

                        sock:setkeepalive(60000, 100)
                    end

                    local ok, err = ngx.timer.at(0, process_in_background)
                    if not ok then
                        ngx.log(ngx.ERR, "Failed to create timer: ", err)
                        stats:incr("failed_requests", 1)
                    end
                }
            }

            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Request-ID $request_id;

            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;

            proxy_buffering off;
            proxy_request_buffering off;
        }
    }
}